<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>HER - 회색지대</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <link rel="manifest" href="manifest.webmanifest" />
  <style>
    * { box-sizing: border-box; padding: 0; margin: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      background: #000;
      touch-action: none;
    }

    /* HUD */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      pointer-events: none;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      z-index: 11;
    }
    #hud-top {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
      font-size: 16px;
      margin-bottom: 4px;
    }
    #hud-hp {
      font-size: 18px;
      font-weight: 700;
      color: #ff5555;
    }
    #hud-timer {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
      z-index: 12;
    }
    #hud-stage {
      font-size: 14px;
      opacity: 0.9;
    }
    #hud-energy {
      font-size: 12px;
      opacity: 0.85;
    }

    /* 귀환 버튼 */
    #returnButton {
      position: fixed;
      right: 16px;
      bottom: 26px;
      width: 130px;
      height: 52px;
      border-radius: 12px;
      background: #222;
      border: 2px solid #555;
      color: #f5f5f5;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.7);
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      z-index: 10;
    }
    #returnButton.active {
      background: #0f3f2a;
      border-color: #00ff99;
      box-shadow: 0 0 18px rgba(0,255,153,0.7);
    }
    #returnButton.disabled {
      opacity: 0.4;
    }

    /* 모바일 조이스틱 (작게) */
    #joystick {
      position: fixed;
      left: 12px;
      bottom: 18px;
      width: 90px;
      height: 90px;
      z-index: 10;
      touch-action: none;
    }
    #stick-base {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.2);
    }
    #stick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 34px;
      height: 34px;
      margin-left: -17px;
      margin-top: -17px;
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
    }

    /* 오버레이 공통 */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.88);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 20;
    }
    .overlay.hidden {
      display: none;
    }
    .overlay-title {
      font-size: 24px;
      margin-bottom: 10px;
      font-weight: 700;
    }
    .overlay-sub {
      font-size: 14px;
      margin-bottom: 18px;
      line-height: 1.6;
      white-space: pre-line;
    }
    .overlay-btn {
      padding: 12px 26px;
      border-radius: 999px;
      border: 1px solid #00ff99;
      background: #0f3f2a;
      color: #f5f5f5;
      font-size: 15px;
      font-weight: 600;
      box-shadow: 0 0 12px rgba(0,255,153,0.7);
      touch-action: manipulation;
    }

    /* 튜토리얼 힌트 (크게) */
    #tutorialHint {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 24px;
      background: rgba(0,0,0,0.9);
      border-radius: 12px;
      border: 2px solid #00ff99;
      font-size: 16px;
      line-height: 1.7;
      text-align: center;
      max-width: 340px;
      z-index: 15;
      box-shadow: 0 0 18px rgba(0,255,153,0.5);
    }
    #tutorialHint.hidden {
      display: none;
    }

    /* 업그레이드 화면 */
    #upgradeOverlay {
      align-items: stretch;
      justify-content: flex-start;
      padding-top: 48px;
    }
    #upgradeOverlay .overlay-title {
      text-align: center;
    }
    #upgradeStats {
      font-size: 14px;
      margin-bottom: 16px;
      text-align: center;
      white-space: pre-line;
    }
    .upgrade-button {
      width: 100%;
      padding: 12px 10px;
      border-radius: 10px;
      border: 1px solid #444;
      background: #202020;
      color: #f5f5f5;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      text-align: left;
      line-height: 1.4;
      touch-action: manipulation;
    }
    .upgrade-title-line {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }
    .upgrade-desc {
      font-size: 12px;
      opacity: 0.8;
    }
    #upgradeContinue {
      margin-top: 16px;
      align-self: center;
    }

    /* 초록 달일 때 전체 화면 테두리 */
    #screenFrame {
      position: fixed;
      inset: 0;
      pointer-events: none;
      border: 3px solid transparent;
      box-shadow: none;
      z-index: 9;
    }
    #screenFrame.green {
      border-color: rgba(0,255,153,0.75);
      box-shadow: 0 0 22px rgba(0,255,153,0.8);
      animation: greenPulse 0.5s infinite alternate;
    }
    @keyframes greenPulse {
      0% { opacity: 0.25; }
      100% { opacity: 1; }
    }

    /* 하단 작은 안내 */
    #smallHint {
      position: fixed;
      bottom: 6px;
      width: 100%;
      text-align: center;
      font-size: 11px;
      opacity: 0.6;
      pointer-events: none;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
    }

    /* 패배 스코어 */
    #deadScoreWrap {
      margin-top: 8px;       /* 설명 텍스트와 간격 */
      margin-bottom: 28px;   /* 최종 스코어와 버튼 사이 간격 */
      text-align: center;
    }
    #deadScoreBreakdown {
      font-size: 13px;
      line-height: 1.7;
      opacity: 0.9;
      white-space: pre-line;
    }
    #deadScoreFinal {
      margin-top: 12px;
      font-size: 22px;
      font-weight: 800;
      color: #00ffcc;
      text-shadow: 0 0 12px rgba(0,255,204,0.9);
      letter-spacing: 0.04em;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="screenFrame"></div>

  <!-- HUD -->
  <div id="hud">
    <div id="hud-top">
      <div id="hud-hp">HP 100</div>
      <div id="hud-stage">Stage 1 (회색지대)</div>
    </div>
    <div id="hud-timer">00:00</div>
    <div id="hud-energy">에너지: 0 | 총: 0</div>
  </div>

  <!-- 귀환 버튼 -->
  <div id="returnButton" class="disabled">현실로 귀환</div>

  <!-- 모바일 조이스틱 -->
  <div id="joystick">
    <div id="stick-base"></div>
    <div id="stick-knob"></div>
  </div>

  <!-- 하단 안내 -->
  <div id="smallHint">왼쪽 동그라미를 드래그해서 이동, 달이 초록색일 때 오른쪽 버튼으로 현실로 귀환</div>

  <!-- 튜토리얼 힌트 -->
  <div id="tutorialHint" class="hidden">
    달이 초록색으로 변했을 때<br>
    <span style="color:#00ff99;font-weight:700;">오른쪽 아래 버튼</span>을 눌러야<br>
    현실로 귀환할 수 있습니다.
  </div>

  <!-- 시작 화면 -->
  <div id="startOverlay" class="overlay">
    <div class="overlay-title">HER</div>
    <div class="overlay-sub">
      회색지대에서 29.5초를 버티고,<br>
      달이 초록색일 때 현실로 귀환하세요.<br><br>
      완전히 패배하면 모든 업그레이드와<br>
      스테이지가 초기화됩니다.
    </div>
    <button id="startButton" class="overlay-btn">터치해서 시작</button>
  </div>

  <!-- 업그레이드 화면 -->
  <div id="upgradeOverlay" class="overlay hidden">
    <div class="overlay-title">현실 - 무기 업그레이드</div>
    <div id="upgradeStats"></div>

    <button class="upgrade-button" data-upgrade="attack">
      <div class="upgrade-title-line">
        <span>공격력 증가</span><span>[10 에너지]</span>
      </div>
      <div class="upgrade-desc">총알과 근접 공격의 피해량이 증가합니다.</div>
    </button>

    <button class="upgrade-button" data-upgrade="fireRate">
      <div class="upgrade-title-line">
        <span>발사 간격 감소</span><span>[10 에너지]</span>
      </div>
      <div class="upgrade-desc">탄환/근접 공격 사이의 대기 시간이 감소합니다.</div>
    </button>

    <button class="upgrade-button" data-upgrade="moveSpeed">
      <div class="upgrade-title-line">
        <span>이동 속도 증가</span><span>[10 에너지]</span>
      </div>
      <div class="upgrade-desc">회색지대에서의 이동 속도가 빨라집니다.</div>
    </button>

    <button id="upgradeContinue" class="overlay-btn">회색지대로 돌아가기 (다음 스테이지)</button>
  </div>

  <!-- 패배 화면 -->
  <div id="deadOverlay" class="overlay hidden">
    <div class="overlay-title">완전 패배</div>
    <div class="overlay-sub">
      회색지대에서 목숨을 잃었습니다.<br>
      지금까지 모은 업그레이드와 스테이지가<br>
      모두 초기화됩니다.
    </div>

    <!-- 스코어 표시 영역 -->
    <div id="deadScoreWrap">
      <div id="deadScoreBreakdown"></div>
      <div id="deadScoreFinal"></div>
    </div>

    <button id="deadRestart" class="overlay-btn">처음부터 다시</button>
  </div>

  <!-- 최종 클리어 -->
  <div id="clearOverlay" class="overlay hidden">
    <div class="overlay-title">HER - 회색지대 탈출</div>
    <div class="overlay-sub">
      자넨 아주 뛰어난 오서독서의 자질을 갖췄구만.
    </div>
    <button id="clearRestart" class="overlay-btn">처음부터 다시</button>
  </div>

  <!-- 음산 BGM (bgm.mp3를 같은 폴더에 두면 재생됨) -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <script>
    // ===== 캔버스 =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let viewW = window.innerWidth;
    let viewH = window.innerHeight;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      viewW = window.innerWidth;
      viewH = window.innerHeight;
      canvas.width = viewW * dpr;
      canvas.height = viewH * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ===== UI 요소 =====
    const hudHp     = document.getElementById('hud-hp');
    const hudTimer  = document.getElementById('hud-timer');
    const hudStage  = document.getElementById('hud-stage');
    const hudEnergy = document.getElementById('hud-energy');
    const screenFrame = document.getElementById('screenFrame');

    const returnButton = document.getElementById('returnButton');

    const joystick   = document.getElementById('joystick');
    const stickBase  = document.getElementById('stick-base');
    const stickKnob  = document.getElementById('stick-knob');

    const tutorialHint   = document.getElementById('tutorialHint');
    const startOverlay   = document.getElementById('startOverlay');
    const startButton    = document.getElementById('startButton');
    const upgradeOverlay = document.getElementById('upgradeOverlay');
    const upgradeStats   = document.getElementById('upgradeStats');
    const upgradeButtons = upgradeOverlay.querySelectorAll('.upgrade-button');
    const upgradeContinue = document.getElementById('upgradeContinue');
    const deadOverlay    = document.getElementById('deadOverlay');
    const deadRestart    = document.getElementById('deadRestart');
    const clearOverlay   = document.getElementById('clearOverlay');
    const clearRestart   = document.getElementById('clearRestart');

    const deadScoreBreakdown = document.getElementById('deadScoreBreakdown');
    const deadScoreFinal     = document.getElementById('deadScoreFinal');

    const bgm = document.getElementById('bgm');
    let bgmStarted = false;
    function ensureBgm() {
      if (bgmStarted) return;
      if (!bgm) return;
      const p = bgm.play();
      if (p && typeof p.then === 'function') {
        p.catch(() => {});
      }
      bgmStarted = true;
    }

    // ===== 조이스틱 =====
    let joyActive = false;
    let joyId = null;
    let joyCenterX = 0;
    let joyCenterY = 0;
    let joyDirX = 0;
    let joyDirY = 0;

    function resetJoystick() {
      joyActive = false;
      joyId = null;
      joyDirX = 0;
      joyDirY = 0;
      stickKnob.style.left = '50%';
      stickKnob.style.top  = '50%';
    }

    function joystickTouchStart(e) {
      e.preventDefault();
      ensureBgm();
      const t = e.changedTouches[0];
      if (!t) return;
      joyActive = true;
      joyId = t.identifier;
      const rect = stickBase.getBoundingClientRect();
      joyCenterX = rect.left + rect.width / 2;
      joyCenterY = rect.top + rect.height / 2;
      joystickTouchMove(e);
    }

    function joystickTouchMove(e) {
      if (!joyActive) return;
      const touches = e.touches;
      let t = null;
      for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === joyId) {
          t = touches[i];
          break;
        }
      }
      if (!t) return;
      const dx = t.clientX - joyCenterX;
      const dy = t.clientY - joyCenterY;

      const maxR = 26; // 짧게
      let dist = Math.hypot(dx, dy);
      let nx = 0, ny = 0;
      if (dist > 0) {
        const clamped = Math.min(dist, maxR);
        nx = dx / dist;
        ny = dy / dist;
        const knobX = joyCenterX + nx * clamped;
        const knobY = joyCenterY + ny * clamped;
        const rect = stickBase.getBoundingClientRect();
        stickKnob.style.left = ((knobX - rect.left) / rect.width * 100) + '%';
        stickKnob.style.top  = ((knobY - rect.top)  / rect.height * 100) + '%';
      } else {
        stickKnob.style.left = '50%';
        stickKnob.style.top  = '50%';
      }

      const deadZone = 0.10;
      const len = Math.hypot(nx, ny);
      if (len < deadZone) {
        joyDirX = 0;
        joyDirY = 0;
      } else {
        joyDirX = nx;
        joyDirY = ny;
      }
    }

    function joystickTouchEnd(e) {
      const touches = e.changedTouches;
      for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === joyId) {
          resetJoystick();
          break;
        }
      }
    }

    joystick.addEventListener('touchstart', joystickTouchStart, {passive:false});
    joystick.addEventListener('touchmove',  joystickTouchMove,  {passive:false});
    joystick.addEventListener('touchend',   joystickTouchEnd,   {passive:false});
    joystick.addEventListener('touchcancel',joystickTouchEnd,   {passive:false});

    // ===== 게임 상태 =====
    let gameMode = 'start'; // start, play, upgrade, dead, clear

    const meta = {
      totalEnergy: 0,
      attackLevel: 0,
      fireRateLevel: 0,
      moveSpeedLevel: 0,
      stageLevel: 0   // 0~4
    };

    // 전체 러닝 동안 누적 스코어
    const stats = {
      totalKills: 0,
      totalSurvivalTime: 0,   // 초 단위 dt 누적
      totalEnergyGained: 0
    };

    let player = null;
    let enemies = [];
    let bullets = [];
    let enemyBullets = [];
    let energies = [];
    let boss = null;

    let runTime = 0;
    let cycleCount = 0;
    let cycleTime = 0;
    let isGreen = false;
    let greenTimer = 0;

    let spawnTimer = 0;
    let difficultyFactor = 1;
    let runEnergy = 0;
    let attackCooldown = 0;

    // ===== 밸런스 상수 =====
    const MELEE_RANGE = 80;
    const BASE_SPAWN_INTERVAL = 1.3;
    const PLAYER_BASE_SPEED = 150;

    const ENEMY_BASE_SPEED = 38;
    const ENEMY_BASE_HP    = 30;

    const BULLET_SPEED  = 240;
    const BULLET_RADIUS = 3;

    const ENEMY_BULLET_SPEED  = 200;
    const ENEMY_BULLET_DAMAGE = 16;
    const ENEMY_ATTACK_COOLDOWN = 2.2;
    const ENEMY_ATTACK_RANGE  = 420;

    const DASH_RANGE      = 520;
    const DASH_DURATION   = 0.45;
    const DASH_COOLDOWN   = 2.4;
    const DASH_SPEED_MULT = 4.0;

    const BULLET_KNOCKBACK = 10;
    const MELEE_KNOCKBACK  = 18;

    const BOSS_CONTACT_DPS        = 18;
    const BOSS_BULLET_DAMAGE_MULT = 0.7;

    const BASE_ATTACK_COOLDOWN = 0.45;

    // ===== 유틸 =====
    function formatTime(t) {
      const s = Math.floor(t);
      const m = Math.floor(s / 60);
      const ss = s % 60;
      return String(m).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
    }

    function rotateVector(x, y, ang) {
      const c = Math.cos(ang);
      const s = Math.sin(ang);
      return [x*c - y*s, x*s + y*c];
    }

    // ===== 업그레이드 / 공격력 =====
    function getPlayerSpeed() {
      return PLAYER_BASE_SPEED * (1 + 0.1 * meta.moveSpeedLevel);
    }
    function getBulletDamage() {
      return 21 * (1 + 0.4 * meta.attackLevel);
    }
    function getMeleeDamage() {
      return 35 * (1 + 0.4 * meta.attackLevel);
    }

    function updateUpgradeUI() {
      upgradeStats.textContent =
        `회색지대 스테이지: ${meta.stageLevel + 1} / 5\n` +
        `보유 현실 에너지: ${meta.totalEnergy}\n` +
        `공격력 Lv.${meta.attackLevel} | 발사 Lv.${meta.fireRateLevel} | 이동 Lv.${meta.moveSpeedLevel}`;
    }

    function attemptUpgrade(type) {
      const cost = 10;
      if (meta.totalEnergy < cost) return;
      meta.totalEnergy -= cost;
      if (type === 'attack')    meta.attackLevel++;
      if (type === 'fireRate')  meta.fireRateLevel++;
      if (type === 'moveSpeed') meta.moveSpeedLevel++;
      updateUpgradeUI();
    }

    upgradeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.upgrade;
        attemptUpgrade(type);
      });
    });

    // ===== 데미지 / 패배 =====
    function damagePlayer(amount) {
      if (gameMode !== 'play') return;
      player.hp -= amount;
      if (player.hp <= 0) {
        player.hp = 0;
        onPlayerDead();
      }
    }

    // 패배 시 스코어 UI 업데이트
    function updateDeadScoreUI() {
      if (!deadScoreBreakdown || !deadScoreFinal) return;

      const kills = stats.totalKills || 0;
      const totalTimeSec = Math.floor(stats.totalSurvivalTime || 0);
      const totalEnergy = stats.totalEnergyGained || 0;
      const totalScore = kills + totalTimeSec + totalEnergy;

      deadScoreBreakdown.textContent =
        `처치한 디소더 수 : ${kills}\n` +
        `총 버틴 시간      : ${totalTimeSec}초\n` +
        `총 획득 에너지    : ${totalEnergy}`;

      deadScoreFinal.textContent = `총 스코어 : ${totalScore}`;
    }

    function resetAllProgress() {
      meta.totalEnergy    = 0;
      meta.attackLevel    = 0;
      meta.fireRateLevel  = 0;
      meta.moveSpeedLevel = 0;
      meta.stageLevel     = 0;

      runEnergy   = 0;
      runTime     = 0;
      cycleCount  = 0;
      cycleTime   = 0;
      isGreen     = false;
      greenTimer  = 0;
      spawnTimer  = 0;
      attackCooldown = 0;
    }

    function resetRunForCurrentStage() {
      gameMode = 'play';

      resetJoystick();
      deadOverlay.classList.add('hidden');
      clearOverlay.classList.add('hidden');
      startOverlay.classList.add('hidden');
      upgradeOverlay.classList.add('hidden');
      tutorialHint.classList.add('hidden');
      screenFrame.classList.remove('green');

      runTime       = 0;
      cycleTime     = 0;
      cycleCount    = 0;
      isGreen       = false;
      greenTimer    = 0;
      spawnTimer    = 0;
      attackCooldown = 0;
      runEnergy     = 0;

      difficultyFactor = 1 + 0.18 * meta.stageLevel;

      player = {
        x: viewW / 2,
        y: viewH / 2,
        radius: 12,
        hp: 100,
        maxHp: 100
      };
      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;

      if (meta.stageLevel === 4) {
        boss = {
          x: viewW / 2,
          y: viewH / 3,
          radius: player.radius * 1.2,
          hp: 2800,
          maxHp: 2800,
          baseSpeed: 45,
          patternCooldown: 1.0
        };
      }

      updateHud();
    }

    function hardRestart() {
      resetAllProgress();
      // 새 생명 시작이므로 스코어도 초기화
      stats.totalKills = 0;
      stats.totalSurvivalTime = 0;
      stats.totalEnergyGained = 0;
      resetRunForCurrentStage();
    }

    function onPlayerDead() {
      gameMode = 'dead';

      // 먼저 스코어 계산해서 화면에 반영
      updateDeadScoreUI();

      // 패배 시 진행 정보 리셋 (메타/스테이지/업그레이드)
      resetAllProgress();

      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;
      isGreen      = false;

      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');
      resetJoystick();

      deadOverlay.classList.remove('hidden');
      upgradeOverlay.classList.add('hidden');
      clearOverlay.classList.add('hidden');
      startOverlay.classList.add('hidden');
    }

    // ===== 현실로 귀환 / 업그레이드 =====
    function moveToUpgrade() {
      gameMode = 'upgrade';
      meta.totalEnergy += runEnergy;
      runEnergy = 0;
      isGreen = false;
      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');
      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;

      updateUpgradeUI();
      upgradeOverlay.classList.remove('hidden');
    }

    function continueToNextStage() {
      if (meta.stageLevel < 4) meta.stageLevel++;
      upgradeOverlay.classList.add('hidden');
      resetRunForCurrentStage();
    }

    upgradeContinue.addEventListener('click', () => {
      ensureBgm();
      continueToNextStage();
    });

    function handleReturnButton() {
      if (gameMode !== 'play') return;
      if (!isGreen) return;
      if (!player || player.hp <= 0) return;
      moveToUpgrade();
    }

    returnButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      ensureBgm();
      handleReturnButton();
    }, {passive:false});
    returnButton.addEventListener('click', (e) => {
      e.preventDefault();
      ensureBgm();
      handleReturnButton();
    });

    // ===== 시작 / 재시작 =====
    function startGameFromTitle() {
      ensureBgm();
      hardRestart();
    }

    startButton.addEventListener('click', () => {
      startGameFromTitle();
    });
    startOverlay.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startGameFromTitle();
    }, {passive:false});

    // ▼ 여기부터 "처음부터 다시" 완전 재시작 로직 ▼
    function restartFromScratch() {
      // 해시로 '재시작 모드' 표시 후 새로고침
      location.hash = '#restart';
      location.reload();
    }

    deadRestart.addEventListener('click', (e) => {
      e.preventDefault();
      restartFromScratch();
    });

    clearRestart.addEventListener('click', (e) => {
      e.preventDefault();
      restartFromScratch();
    });

    // ===== 적 / 에너지 / 보스 =====
    function getEnergyAmountForType(type) {
      if (type === 'dasher')  return 1;
      if (type === 'fast')    return 2;
      if (type === 'slow')    return 2;
      if (type === 'runner')  return 4;
      if (type === 'spreader')return 8;
      return 1;
    }

    function chooseEnemyType() {
      let stage = meta.stageLevel;

      // 튜토리얼에서 오래 버티면 다른 적 등장
      if (stage === 0) {
        if (cycleCount >= 2) stage = 2;
        else if (cycleCount >= 1) stage = 1;
      }

      if (stage >= 4) stage = 3; // 5스테는 보스

      const r = Math.random();
      if (stage === 0) {
        return 'dasher';
      } else if (stage === 1) {
        if (r < 0.6) return 'dasher';
        return 'fast';
      } else if (stage === 2) {
        if (r < 0.4) return 'dasher';
        else if (r < 0.7) return 'fast';
        else return 'slow';
      } else {
        if (r < 0.30) return 'dasher';
        else if (r < 0.55) return 'fast';
        else if (r < 0.75) return 'slow';
        else if (r < 0.88) return 'runner';
        else return 'spreader'; // 12%
      }
    }

    function spawnEnemy() {
      if (meta.stageLevel === 4) return;

      const side = Math.floor(Math.random() * 4);
      let x, y;
      if (side === 0) { x = -20;         y = Math.random() * viewH; }
      else if (side === 1) { x = viewW + 20; y = Math.random() * viewH; }
      else if (side === 2) { x = Math.random() * viewW; y = -20; }
      else { x = Math.random() * viewW; y = viewH + 20; }

      const type = chooseEnemyType();
      const energyTier = getEnergyAmountForType(type);
      const diff = difficultyFactor;

      let hp = ENEMY_BASE_HP * diff;
      let baseSpeed = ENEMY_BASE_SPEED * diff;

      if (type === 'dasher') {
        hp *= 1.0;
        baseSpeed *= 1.0;
      } else if (type === 'fast') {
        hp *= 1.2;
        baseSpeed *= 1.2;
      } else if (type === 'slow') {
        hp *= 1.6;
        baseSpeed *= 0.7;
      } else if (type === 'runner') {
        hp *= 1.3;
        baseSpeed *= 1.7;
      } else if (type === 'spreader') {
        hp *= 1.9;
        baseSpeed *= 0.9;
      }

      enemies.push({
        x, y,
        radius: 10,
        hp,
        baseSpeed,
        type,
        energyTier,
        attackCooldown: 0.6 + Math.random(),
        dashTime: 0
      });
    }

    function spawnEnemyBullet(x, y, ux, uy, speed, damage) {
      enemyBullets.push({
        x, y,
        vx: ux * speed,
        vy: uy * speed,
        radius: 3,
        damage
      });
    }

    function performEnemyAttack(e, dx, dy) {
      const d = Math.hypot(dx, dy) || 1;
      const ux = dx / d;
      const uy = dy / d;

      const baseCd = ENEMY_ATTACK_COOLDOWN / difficultyFactor;
      let cdMul = 1;

      if (e.type === 'fast') {
        spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 1.5, ENEMY_BULLET_DAMAGE * 0.9);
        cdMul = 0.9;
      } else if (e.type === 'slow') {
        spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 0.6, ENEMY_BULLET_DAMAGE * 1.3);
        cdMul = 1.3;
      } else if (e.type === 'runner') {
        if (Math.random() < 0.45) {
          spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 1.1, ENEMY_BULLET_DAMAGE * 0.7);
        }
        cdMul = 1.5;
      } else if (e.type === 'spreader') {
        const step = 0.18;
        for (let i = -3; i <= 3; i++) {
          const ang = i * step;
          const [vx, vy] = rotateVector(ux, uy, ang);
          spawnEnemyBullet(e.x, e.y, vx, vy, ENEMY_BULLET_SPEED * 1.0, ENEMY_BULLET_DAMAGE * 0.9);
        }
        cdMul = 1.6;
      } else {
        if (Math.random() < 0.3) {
          spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED, ENEMY_BULLET_DAMAGE);
        }
        cdMul = 1.4;
      }

      e.attackCooldown = baseCd * cdMul * (0.7 + Math.random() * 0.7);
    }

    // ===== 보스 =====
    function updateBoss(dt) {
      if (!boss || gameMode !== 'play') return;

      const dx = player.x - boss.x;
      const dy = player.y - boss.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = boss.baseSpeed;
      boss.x += (dx / dist) * speed * dt;
      boss.y += (dy / dist) * speed * dt;

      const pd = Math.hypot(player.x - boss.x, player.y - boss.y);
      if (pd < player.radius + boss.radius) {
        damagePlayer(BOSS_CONTACT_DPS * dt);
      }

      boss.patternCooldown -= dt;
      if (boss.patternCooldown <= 0) {
        performBossPattern();
        boss.patternCooldown = 1.0;
      }

      if (boss.hp <= 0 && gameMode === 'play') {
        boss.hp = 0;
        boss = null;
        runEnergy += 8;
        stats.totalKills += 1;
        stats.totalEnergyGained += 8;
        onGameClear();
      }
    }

    function performBossPattern() {
      if (!boss || !player) return;

      const dx = player.x - boss.x;
      const dy = player.y - boss.y;
      const dist = Math.hypot(dx, dy) || 1;
      const ux = dx / dist;
      const uy = dy / dist;

      const pattern = Math.floor(Math.random() * 4);

      if (pattern === 0) {
        const count = 18;
        const step = 0.16;
        for (let i = 0; i < count; i++) {
          const offset = (i - (count-1)/2) * step;
          const [vx, vy] = rotateVector(ux, uy, offset);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.3,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      } else if (pattern === 1) {
        const angles = [-0.18, 0, 0.18];
        const speeds = [
          ENEMY_BULLET_SPEED * 1.3,
          ENEMY_BULLET_SPEED * 1.1,
          ENEMY_BULLET_SPEED * 0.9
        ];
        for (let k = 0; k < angles.length; k++) {
          const base = angles[k];
          for (let i = -2; i <= 2; i++) {
            const off = base + i * 0.06;
            const [vx, vy] = rotateVector(ux, uy, off);
            spawnEnemyBullet(
              boss.x, boss.y,
              vx, vy,
              speeds[k],
              ENEMY_BULLET_DAMAGE * 0.7 * BOSS_BULLET_DAMAGE_MULT
            );
          }
        }
      } else if (pattern === 2) {
        const baseCount = 10;
        for (let i = 0; i < baseCount; i++) {
          const ang = (Math.PI * 2 * i) / baseCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 0.9,
            ENEMY_BULLET_DAMAGE * 0.9 * BOSS_BULLET_DAMAGE_MULT
          );
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.3,
            ENEMY_BULLET_DAMAGE * 0.7 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      } else {
        const outerCount = 24;
        const innerCount = 16;
        for (let i = 0; i < outerCount; i++) {
          const ang = (Math.PI * 2 * i) / outerCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.0,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
        for (let i = 0; i < innerCount; i++) {
          const ang = (Math.PI * 2 * i) / innerCount + Math.PI / innerCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 0.7,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      }
    }

    function onGameClear() {
      gameMode = 'clear';
      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      isGreen      = false;
      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');

      clearOverlay.classList.remove('hidden');
    }

    // ===== 메인 업데이트 =====
    function update(dt) {
      if (gameMode !== 'play') return;
      if (!player) return;

      runTime += dt;
      stats.totalSurvivalTime += dt;
      cycleTime += dt;

      if (!isGreen && cycleTime >= 29.5) {
        isGreen = true;
        greenTimer = 2.0;
        cycleTime = 0;
        cycleCount++;

        if (meta.stageLevel === 0) {
          tutorialHint.classList.remove('hidden');
        }
      }
      if (isGreen) {
        greenTimer -= dt;
        if (greenTimer <= 0) {
          isGreen = false;
          greenTimer = 0;
          tutorialHint.classList.add('hidden');
        }
      }

      if (meta.stageLevel !== 4) {
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
          spawnEnemy();
          spawnEnemy(); // 2배
          const diffMul = 1 + 0.15 * meta.stageLevel + 0.15 * cycleCount;
          spawnTimer = (BASE_SPAWN_INTERVAL / diffMul) * (0.7 + Math.random() * 0.6);
        }
      }

      // 플레이어 이동
      let mvx = joyDirX;
      let mvy = joyDirY;
      if (mvx !== 0 || mvy !== 0) {
        const len = Math.hypot(mvx, mvy) || 1;
        mvx /= len;
        mvy /= len;
        const speed = getPlayerSpeed();
        player.x += mvx * speed * dt;
        player.y += mvy * speed * dt;
      }
      player.x = Math.max(player.radius, Math.min(viewW - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(viewH - player.radius, player.y));

      // 적 이동 / 공격
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;

        let speed = e.baseSpeed;
        if (e.type === 'dasher') {
          if (e.dashTime > 0) {
            speed *= DASH_SPEED_MULT;
            e.dashTime -= dt;
          }
          e.attackCooldown -= dt;
          if (e.attackCooldown <= 0 && dist < DASH_RANGE) {
            e.dashTime = DASH_DURATION;
            e.attackCooldown = (DASH_COOLDOWN / difficultyFactor) * (0.8 + Math.random() * 0.6);
          }
        } else {
          e.attackCooldown -= dt;
          if (e.attackCooldown <= 0 && dist < ENEMY_ATTACK_RANGE) {
            performEnemyAttack(e, dx, dy);
          }
        }

        e.x += (dx / dist) * speed * dt;
        e.y += (dy / dist) * speed * dt;

        if (dist < player.radius + e.radius) {
          const contactDps = (e.type === 'dasher') ? 36 : 16;
          damagePlayer(contactDps * dt);
        }
      }

      // 보스
      if (meta.stageLevel === 4) {
        updateBoss(dt);
      }

      // 자동 공격
      attackCooldown -= dt;
      if (attackCooldown <= 0) {
        let nearest = null;
        let nearestDist = Infinity;

        enemies.forEach(e => {
          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = e;
          }
        });

        if (boss && boss.hp > 0) {
          const dx = boss.x - player.x;
          const dy = boss.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = boss;
          }
        }

        if (nearest) {
          const fireRateMul = 1 + 0.10 * meta.fireRateLevel;
          const dx = nearest.x - player.x;
          const dy = nearest.y - player.y;
          const dist = Math.hypot(dx, dy) || 1;

          if (dist <= MELEE_RANGE) {
            const dmg = getMeleeDamage();
            if (nearest === boss) boss.hp -= dmg;
            else nearest.hp -= dmg;

            const nd = Math.hypot(dx, dy) || 1;
            if (nearest !== boss) {
              nearest.x += (dx / nd) * MELEE_KNOCKBACK;
              nearest.y += (dy / nd) * MELEE_KNOCKBACK;
            }
            attackCooldown = BASE_ATTACK_COOLDOWN / fireRateMul;
          } else {
            bullets.push({
              x: player.x,
              y: player.y,
              vx: (dx / dist) * BULLET_SPEED,
              vy: (dy / dist) * BULLET_SPEED,
              radius: BULLET_RADIUS,
              damage: getBulletDamage()
            });
            attackCooldown = BASE_ATTACK_COOLDOWN / fireRateMul;
          }
        }
      }

      // 플레이어 탄
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.x < -40 || b.x > viewW + 40 || b.y < -40 || b.y > viewH + 40) {
          bullets.splice(i, 1);
          continue;
        }

        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          const dx = e.x - b.x;
          const dy = e.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < e.radius + b.radius) {
            e.hp -= b.damage;
            const vl = Math.hypot(b.vx, b.vy) || 1;
            e.x += (b.vx / vl) * BULLET_KNOCKBACK;
            e.y += (b.vy / vl) * BULLET_KNOCKBACK;
            hit = true;
            break;
          }
        }

        if (!hit && boss && boss.hp > 0) {
          const dx = boss.x - b.x;
          const dy = boss.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < boss.radius + b.radius) {
            boss.hp -= b.damage;
            hit = true;
          }
        }

        if (hit) bullets.splice(i, 1);
      }

      // 적 사망 → 에너지
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (e.hp <= 0) {
          enemies.splice(i, 1);
          stats.totalKills += 1;
          const amount = getEnergyAmountForType(e.type);
          let r = 3;
          if (amount === 2) r = 5;
          else if (amount === 4) r = 7;
          else if (amount >= 8) r = 9;
          energies.push({
            x: e.x,
            y: e.y,
            radius: r,
            amount,
            life: 5.0
          });
        }
      }

      // 적 탄
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.x += eb.vx * dt;
        eb.y += eb.vy * dt;
        if (eb.x < -40 || eb.x > viewW + 40 || eb.y < -40 || eb.y > viewH + 40) {
          enemyBullets.splice(i, 1);
          continue;
        }
        const dx = eb.x - player.x;
        const dy = eb.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < eb.radius + player.radius) {
          damagePlayer(eb.damage);
          enemyBullets.splice(i, 1);
        }
      }

      // 에너지 파편
      for (let i = energies.length - 1; i >= 0; i--) {
        const g = energies[i];
        g.life -= dt;
        if (g.life <= 0) {
          energies.splice(i, 1);
          continue;
        }
        const dx = g.x - player.x;
        const dy = g.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.radius + g.radius) {
          runEnergy += g.amount;
          stats.totalEnergyGained += g.amount;
          energies.splice(i, 1);
        }
      }

      updateHud();
    }

    function updateHud() {
      const stageNum = meta.stageLevel + 1;
      hudStage.textContent = `Stage ${stageNum} (회색지대)`;
      hudHp.textContent = `HP ${player ? Math.round(player.hp) : 0}`;
      hudTimer.textContent = formatTime(runTime);
      hudEnergy.textContent = `에너지: ${runEnergy} | 총: ${meta.totalEnergy}`;

      if (gameMode === 'play' && isGreen && player && player.hp > 0) {
        returnButton.classList.remove('disabled');
        returnButton.classList.add('active');
      } else {
        returnButton.classList.add('disabled');
        returnButton.classList.remove('active');
      }

      screenFrame.classList.toggle('green', (gameMode === 'play' && isGreen));
    }

    // ===== 렌더 =====
    function draw() {
      if (!ctx) return;

      const grad = ctx.createRadialGradient(
        viewW/2, viewH/2, 40,
        viewW/2, viewH/2, Math.max(viewW, viewH)
      );
      grad.addColorStop(0, '#050515');
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, viewW, viewH);

      // 달 (우측 상단)
      const moonX = viewW - 60;
      const moonY = 50;
      ctx.save();
      ctx.translate(moonX, moonY);
      ctx.beginPath();
      ctx.arc(0, 0, 28, 0, Math.PI * 2);
      ctx.fillStyle = isGreen ? '#00ff99' : '#ff4444';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#ffffff';
      ctx.stroke();

      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(0, 0, 42, 0, Math.PI * 2);
      ctx.strokeStyle = isGreen ? '#00ffbb' : '#ff8888';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();

      if (!player) return;

      // 플레이어
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#4af0ff';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius+3, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(74,240,255,0.4)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // 근접 범위
      ctx.beginPath();
      ctx.arc(player.x, player.y, MELEE_RANGE, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // 적
      enemies.forEach(e => {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#555555';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius+3, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(30,30,30,0.9)';
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius-4, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(190,190,220,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // 보스
      if (boss && boss.hp > 0) {
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#333399';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius+6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(200,200,255,0.8)';
        ctx.lineWidth = 4;
        ctx.stroke();

        const barW = Math.min(viewW - 40, 260);
        const barH = 14;
        const x = (viewW - barW) / 2;
        const y = 90;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(x-2, y-2, barW+4, barH+4);
        const ratio = Math.max(0, boss.hp / boss.maxHp);
        ctx.fillStyle = '#00ff99';
        ctx.fillRect(x, y, barW * ratio, barH);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, barW, barH);
        ctx.font = '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`BOSS HP ${Math.max(0, Math.round(boss.hp))}/${boss.maxHp}`, x + barW/2, y - 4);
      }

      // 플레이어 탄
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#00b7ff';
        ctx.fill();
      });

      // 적 탄
      enemyBullets.forEach(eb => {
        ctx.beginPath();
        ctx.arc(eb.x, eb.y, eb.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ff6666';
        ctx.fill();
      });

      // 에너지
      energies.forEach(g => {
        const alpha = Math.max(0, Math.min(1, g.life / 5));
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,213,74,${0.3 + 0.5*alpha})`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius+2, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255,213,74,${0.4*alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    // ===== 루프 =====
    let lastTime = performance.now();
    function loop(now) {
      const dtRaw = (now - lastTime) / 1000;
      lastTime = now;
      const dt = Math.min(dtRaw, 0.05);

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ▼ 해시가 #restart 인 상태로 들어온 경우 → 즉시 1스테이지부터 다시 시작
    if (location.hash === '#restart') {
      // 주소창에서 #restart 제거
      if (history.replaceState) {
        history.replaceState(null, '', location.pathname + location.search);
      } else {
        location.hash = '';
      }
      resetAllProgress();
      stats.totalKills = 0;
      stats.totalSurvivalTime = 0;
      stats.totalEnergyGained = 0;
      resetRunForCurrentStage();
    }

    // ===== 서비스워커 (옵션) =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }
  </script>
</body>
</html>
